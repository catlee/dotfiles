export PATH=$HOME/.local/bin:$PATH
export PATH=$HOME/.cargo/bin:$PATH

# oh-my-zsh
ZSH=$HOME/.oh-my-zsh

DRACULA_DISPLAY_FULL_CWD=0
DRACULA_DISPLAY_TIME=1
DRACULA_DISPLAY_CONTEXT=0
ZSH_THEME="dracula/dracula"
VI_MODE_SET_CURSOR=true
MODE_INDICATOR="%F{green}(N)%f"

plugins=(git vi-mode zsh-syntax-highlighting)

source $ZSH/oh-my-zsh.sh

# Git worktree detection for prompt
function _get_worktree_name() {
    # Check if we're in a git repository
    if ! git rev-parse --git-dir &>/dev/null; then
        return
    fi

    # Get the git directory
    local git_dir=$(git rev-parse --git-dir 2>/dev/null)

    # Check if we're in a worktree (not the main working tree)
    if [[ "$git_dir" == *"/.git/worktrees/"* ]]; then
        # Extract worktree name from the git directory path
        local worktree_name="${git_dir#*/.git/worktrees/}"
        worktree_name="${worktree_name%%/*}"
        echo "${worktree_name}"
    elif [[ -f "$git_dir" ]]; then
        # If .git is a file (not a directory), we're in a worktree
        # Read the gitdir path from the file
        local gitdir_path=$(<"$git_dir")
        gitdir_path="${gitdir_path#gitdir: }"
        if [[ "$gitdir_path" == *"/worktrees/"* ]]; then
            local worktree_name="${gitdir_path#*/worktrees/}"
            worktree_name="${worktree_name%%/*}"
            echo "${worktree_name}"
        fi
    else
        # Check if current path is under ~/world/trees (special case for your setup)
        local current_path=$(pwd)
        if [[ "$current_path" == "$HOME/world/trees/"* ]]; then
            # Extract the worktree name (first directory under trees/)
            local relative_path="${current_path#$HOME/world/trees/}"
            local worktree_name="${relative_path%%/*}"
            if [[ -n "$worktree_name" ]]; then
                echo "${worktree_name}"
            fi
        fi
    fi
}

# Extend the prompt with worktree info
# We modify PROMPT once after theme loads to inject worktree display
# The worktree info will be dynamically updated via the WORKTREE_PROMPT variable

# Function to show worktree info in prompt
function _worktree_prompt_info() {
    local worktree_name=$(_get_worktree_name)
    if [[ -n "$worktree_name" ]]; then
        echo "%F{yellow}[wt:${worktree_name}]%f "
    fi
}

# Inject worktree info into the prompt after the directory segment
# We do this once after the theme loads
if [[ "$PROMPT" == *'%F{blue}%B$(dracula_directory)'* ]]; then
    PROMPT=${PROMPT//'%F{blue}%B$(dracula_directory)'/'%F{blue}%B$(dracula_directory)$(_worktree_prompt_info)'}
fi

export EDITOR=nvim
export PAGER=less

# Don't print an error if no matches for glob
setopt nonomatch

# Directory stacks
setopt autopushd pushdignoredups

setopt extendedglob
# setopt shwordsplit
setopt PROMPT_SUBST

export ZSH_THEME_TERM_TITLE_IDLE="%20<...<%~"
export ZSH_THEME_TERM_TAB_TITLE_IDLE="%20<...<%~"

# Dynamic terminal title
function precmd() {
    # Set terminal title to current directory (shortened)
    print -Pn "\e]0;%20<...<%~\a"
}

function preexec() {
    # Set terminal title to show the command being run
    local cmd=$1
    if [[ $cmd =~ ^(nvim|vim|vi|nano|emacs) ]]; then
        # Extract filename from editor commands
        local file=$(echo $cmd | awk '{print $2}')
        if [[ -n $file ]]; then
            print -Pn "\e]0;nvim: ${file:t}\a"
        else
            print -Pn "\e]0;$cmd\a"
        fi
    else
        print -Pn "\e]0;$cmd\a"
    fi
}

# History stuff
setopt histfindnodups histignoredups histreduceblanks
setopt incappendhistory histexpiredupsfirst extendedhistory
unsetopt share_history
HISTFILE=~/.zsh_history
SAVEHIST=10000
HISTSIZE=20000
setopt HIST_EXPIRE_DUPS_FIRST

# TAB-completion
zstyle ':completion:*' completer _complete _match _approximate

source ~/.aliases

# Edit line in vim with ctrl-e:
autoload edit-command-line; zle -N edit-command-line
bindkey '^e' edit-command-line

[ -f /opt/dev/dev.sh ] && source /opt/dev/dev.sh

# Fuzzy finding
export FZF_DEFAULT_OPTS='--height 40%'
export FZF_CTRL_T_COMMAND="fd --type f --hidden"
export FZF_DEFAULT_COMMAND="fd --type f"
[ -f ~/.fzf.zsh ] && source ~/.fzf.zsh

# Homebrew
[[ -x /opt/homebrew/bin/brew ]] && eval $(/opt/homebrew/bin/brew shellenv)

# TERM setup
[[ "$TERM" == "screen" && -n "$TMUX" ]] && export TERM=screen-256color

# Ruby stuff
[[ -f /opt/dev/sh/chruby/chruby.sh ]] && { type chruby >/dev/null 2>&1 || chruby () { source /opt/dev/sh/chruby/chruby.sh; chruby "$@"; } }

# Python stuff
# if [ -d $HOME/.pyenv ]; then
#     export PYENV_ROOT=$HOME/.pyenv
#     export PATH=$PYENV_ROOT/bin:$PATH
#     eval "$(pyenv init -)"
# fi

# zoxide
if [ -x "$(command -v zoxide)" ]; then
    eval "$(zoxide init zsh)"
fi

fpath=( ~/.zsh/functions/ "${fpath[@]}" )
autoload -U $fpath[1]/*(@,.:t)

# Added by tec agent
[[ -x /Users/chrisatlee/.local/state/tec/profiles/base/current/global/init ]] && eval "$(/Users/chrisatlee/.local/state/tec/profiles/base/current/global/init zsh)"
